<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>rpmbuild构建rpm包</title>
      <link href="2021/05/20/rpmbuild/"/>
      <url>2021/05/20/rpmbuild/</url>
      
        <content type="html"><![CDATA[<h1 id="rpmbuild构建rpm包"><a href="#rpmbuild构建rpm包" class="headerlink" title="rpmbuild构建rpm包"></a>rpmbuild构建rpm包</h1><p>RPM（Redhat Package Manager）是用于Redhat、CentOS、Fedora等Linux 分发版（distribution）的常见的软件包管理器。</p><h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1.准备"></a>1.准备</h2><p>首先请准备一个Linux环境，比如CentOS。 RPM打包使用的是<code>rpmbuild</code>命令，这个命令来自rpm-build包，这个是必装的。</p><pre class="line-numbers language-none"><code class="language-none">$ yum install rpm-build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然也可以直接安装rpmdevtools，这个工具还包含一些其他的工具，同时它依赖rpm-build，所以直接安装的话会同时把rpm-build装上。</p><pre class="line-numbers language-none"><code class="language-none">$ yum install rpmdevtools<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h2><p>RPM打包的时候需要编译源码，还需要把编译好的配置文件啊二进制命令文件啊之类的东西按照安装好的样子放到合适的位置，还要根据需要对RPM的包进行测试，这些都需要先有一个“工作空间”。<code>rpmbuild</code>命令使用一套标准化的“工作空间”：</p><pre class="line-numbers language-none"><code class="language-none">$ rpmdev-setuptree<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>rpmdev-setuptree这个命令就是安装rpmdevtools带来的。可以看到运行了这个命令之后，在$HOME家目录下多了一个叫做rpmbuild的文件夹，里边内容如下：</p><pre class="line-numbers language-none"><code class="language-none">$ tree rpmbuildrpmbuild├── BUILD├── RPMS├── SOURCES├── SPECS└── SRPMS————————————————<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以手动创建这些目录。</p><p>从这些文件的名字大体也能看得出来都是干嘛用的。具体来说：</p><table><thead><tr><th><strong>默认位置</strong></th><th><strong>宏代码</strong></th><th><strong>名称</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td>~/rpmbuild/SPECS</td><td>%_specdir</td><td>Spec 文件目录</td><td>保存 RPM 包配置（.spec）文件</td></tr><tr><td>~/rpmbuild/SOURCES</td><td>%_sourcedir</td><td>源代码目录</td><td>保存源码包（如 .tar 包）和所有 patch 补丁</td></tr><tr><td>~/rpmbuild/BUILD</td><td>%_builddir</td><td>构建目录</td><td>源码包被解压至此，并在该目录的子目录完成编译</td></tr><tr><td>~/rpmbuild/BUILDROOT</td><td>%_buildrootdir</td><td>最终安装目录</td><td>保存 %install 阶段安装的文件</td></tr><tr><td>~/rpmbuild/RPMS</td><td>%_rpmdir</td><td>标准 RPM 包目录</td><td>生成/保存二进制 RPM 包</td></tr><tr><td>~/rpmbuild/SRPMS</td><td>%_srcrpmdir</td><td>源代码 RPM 包目录</td><td>生成/保存源码 RPM 包(SRPM)</td></tr></tbody></table><p>SPECS下是RPM包的配置文件，是RPM打包的“图纸”，这个文件会告诉<code>rpmbuild</code>命令如何去打包。“宏代码”这一列就可以在SPEC文件中用来代指所对应的目录，类似于编程语言中的宏或全局变量。当然<code>~/rpmbuild</code>这个文件夹也是有宏代码的，叫做<code>%_topdir</code>。</p><p>打包的过程有点像是流水线，分好几个工序：</p><ol><li>首先，需要把源代码放到%_sourcedir中；</li><li>然后，进行编译，编译的过程是在%_builddir中完成的，所以需要先把源代码复制到这个目录下边，一般情况下，源代码是压缩包格式，那么就解压过来即可；</li><li>第三步，进行“安装”，这里有点类似于预先组装软件包，把软件包应该包含的内容（比如二进制文件、配置文件、man文档等）复制到%*buildrootdir中，并按照实际安装后的目录结构组装，比如二进制命令可能会放在/usr/bin下，那么就在%*buildrootdir下也按照同样的目录结构放置；</li><li>然后，需要配置一些必要的工作，比如在实际安装前的准备啦，安装后的清理啦，以及在卸载前后要做的工作啦等等，这样也都是通过配置在SPEC文件中来告诉rpmbuild命令；</li><li>还有一步可选操作，那就是检查软件是否正常运行；</li><li>最后，生成的RPM包放置到%rpmdir，源码包放置到%srpmdir下。</li></ol><table><thead><tr><th><strong>阶段</strong></th><th>读取的目录</th><th><strong>写入的目录</strong></th><th><strong>具体动作</strong></th></tr></thead><tbody><tr><td>%prep</td><td>%_sourcedir</td><td>%_builddir</td><td>读取位于 <code>%_sourcedir</code> 目录的源代码和 patch 。之后，解压源代码至 <code>%_builddir</code> 的子目录并应用所有 patch。</td></tr><tr><td>%build</td><td>%_builddir</td><td>%_builddir</td><td>编译位于 <code>%_builddir</code> 构建目录下的文件。通过执行类似 <code>./configure &amp;&amp; make</code> 的命令实现。</td></tr><tr><td>%install</td><td>%_builddir</td><td>%_buildrootdir</td><td>读取位于 <code>%_builddir</code> 构建目录下的文件并将其安装至 <code>%_buildrootdir</code> 目录。这些文件就是用户安装 RPM 后，最终得到的文件。注意一个奇怪的地方: 最终安装目录 不是 构建目录。通过执行类似 <code>make install</code> 的命令实现。</td></tr><tr><td>%check</td><td>%_builddir</td><td>%_builddir</td><td>检查软件是否正常运行。通过执行类似 <code>make test</code> 的命令实现。很多软件包都不需要此步。</td></tr><tr><td>bin</td><td>%_buildrootdir</td><td>%_rpmdir</td><td>读取位于 <code>%_buildrootdir</code> 最终安装目录下的文件，以便最终在 <code>%_rpmdir</code> 目录下创建 RPM 包。在该目录下，不同架构的 RPM 包会分别保存至不同子目录， <code>noarch</code> 目录保存适用于所有架构的 RPM 包。这些 RPM 文件就是用户最终安装的 RPM 包。</td></tr><tr><td>src</td><td>%_sourcedir</td><td>%_srcrpmdir</td><td>创建源码 RPM 包（简称 SRPM，以<code>.src.rpm</code> 作为后缀名），并保存至 <code>%_srcrpmdir</code> 目录。SRPM 包通常用于审核和升级软件包。</td></tr></tbody></table><h2 id="3-示例"><a href="#3-示例" class="headerlink" title="3.示例"></a>3.示例</h2><h3 id="3-1打包源码"><a href="#3-1打包源码" class="headerlink" title="3.1打包源码"></a>3.1打包源码</h3><p>$ cd ~/rpmbuild/SOURCES </p><p>[jyl@localhost SOURCES]$ ls mbctool-0.0.1.tar.gz</p><h3 id="3-2-编辑SPEC文件"><a href="#3-2-编辑SPEC文件" class="headerlink" title="3.2 编辑SPEC文件"></a>3.2 编辑SPEC文件</h3><p>然后后续的步骤就交给SPEC文件来配置了，编辑SPEC文件(vi可自动生成模版)</p><pre class="line-numbers language-none"><code class="language-none">[jyl@localhost SPECS]$ cd ~&#x2F;rpmbuild&#x2F;SPECS&#x2F;[jyl@localhost SPECS]$ vi mbctool.specName:           mbctoolVersion:        0.0.1Release:        1%&#123;?dist&#125;Summary:        &quot;Linx mbc tools&quot;License:        GPLURL:            http:&#x2F;&#x2F;www.linx-info.comSource0:        ftp:&#x2F;&#x2F;&#x2F;home&#x2F;jyl&#x2F;rpmbuild&#x2F;SOURCES&#x2F;mbctool-0.0.1.tar.gz#BuildRequires:  gettext#Requires:       info%descriptionThe tools, done linx mbc setting%description -l zh_CNmbc工具，实现凝思强制行为控制配置%prep%setup -q%build%configuremake %&#123;?_smp_mflags&#125;%installmake install DESTDIR&#x3D;%&#123;buildroot&#125;rm -rf $RPM_BUILD_ROOT%make_install%files%attr(0755, root, root) &#x2F;lib&#x2F;*%attr(0755, root, root) &#x2F;sbin&#x2F;*%attr(0644, root, root) &#x2F;usr&#x2F;include&#x2F;*%doc%changelog* Fri Apr 30 2021 Jia Yulin &lt;yljia@linx-info.com&gt; - 0.0.1- build V0.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>Name 标签就是软件名，Version 标签为版本号，而 Release 是发布编号。</li><li>Summary 标签是简要说明，英文的话第一个字母应大写，以避免 rpmlint 工具（打包检查工具）警告。</li><li>License 标签说明软件包的协议版本，审查软件的 License 状态是打包者的职责，这可以通过检查源码或 LICENSE 文件，或与作者沟通来完成。</li><li>Group 标签过去用于按照 /usr/share/doc/rpm-/GROUPS 分类软件包。目前该标记已丢弃，vim的模板还有这一条，删掉即可，不过添加该标记也不会有任何影响。 %changelog 标签应包含每个 Release 所做的更改日志，尤其应包含上游的安全/漏洞补丁的说明。Changelog 日志可使用 rpm –changelog -q <packagename> 查询，通过查询可得知已安装的软件是否包含指定漏洞和安全补丁。%changelog 条目应包含版本字符串，以避免 rpmlint 工具警告。</li><li>多行的部分，如 %changelog 或 %description 由指令下一行开始，空行结束。</li><li>一些不需要的行 (如 BuildRequires 和 Requires) 可使用 ‘#’ 注释。</li><li>%files指定要安装的文件，%attr可指定安装文件的属性和权限。</li><li>%prep、%build、%install暂时用默认的，未做任何修改。</li></ol><h3 id="3-3-构建RPM包"><a href="#3-3-构建RPM包" class="headerlink" title="3.3 构建RPM包"></a>3.3 构建RPM包</h3><p>以构建源码、二进制和包含调试信息的软件包：</p><pre class="line-numbers language-none"><code class="language-none">[jyl@localhost SPECS]$ rpmbuild -ba mbctool.spec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行成功，查看结果：</p><pre class="line-numbers language-none"><code class="language-none">[jyl@localhost SPECS]$ tree ~&#x2F;rpmbuild&#x2F;*RPMS&#x2F;home&#x2F;jyl&#x2F;rpmbuild&#x2F;RPMS└── x86_64    ├── mbctool-0.0.1-1.el7.bclinux.x86_64.rpm    └── mbctool-debuginfo-0.0.1-1.el7.bclinux.x86_64.rpm&#x2F;home&#x2F;jyl&#x2F;rpmbuild&#x2F;SRPMS└── mbctool-0.0.1-1.el7.bclinux.src.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在RPMS文件夹下生成了RPM包，在<code>x86_64</code>下，表示所应用的架构，由于没有指定arch为<code>noarch</code>，所以默认用本机架构。在SRPMS文件夹下生产了源码包，源码包当然木有架构这一说了。</p><p>可通过命令安装生成的包：</p><pre class="line-numbers language-none"><code class="language-none">[jyl@localhost x86_64]$ rpm -ivh mbctool-0.0.1-1.el7.bclinux.x86_64.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-详解"><a href="#4-详解" class="headerlink" title="4.详解"></a>4.详解</h2><p>SPEC文件是RPM打包的核心，下面就对SPEC文件中漏掉的而且比较重要的关于各个部分的配置方法进行详细说明：</p><h3 id="4-1-prep阶段"><a href="#4-1-prep阶段" class="headerlink" title="4.1 %prep阶段"></a>4.1 %prep阶段</h3><p>%prep 部分描述了解压源码包的方法。一般而言，其中包含 %autosetup 命令。另外，还可以使用 %setup 和 %patch 命令来指定操作 Source0、Patch0 等标签的文件。</p><p>%autosetup 命令 %autosetup 命令用于解压源码包。可用选项包括：</p><ul><li>-n name : 如果源码包解压后的目录名称与 RPM 名称不同，此选项用于指定正确的目录名称。例如，如果 tarball 解压目录为 FOO，则使用 “%autosetup -n FOO”。</li><li>-c name : 如果源码包解压后包含多个目录，而不是单个目录时，此选项可以创建名为 name 的目录，并在其中解压。</li></ul><p>%setup 命令 如果使用 %setup 命令，通常使用 -q 抑止不必要的输出。 如果需要解压多个文件，有更多 %spec 选项可用，这对于创建子包很有用。常用选项如下：</p><ul><li>-a number：在切换目录后，只解压指定序号的 Source 文件（例如 “-a 0” 表示 Source0）。</li><li>-b number ：在切换目录前， 只解压指定序号的 Source 文件（例如 “-b 0” 表示 Source0）。</li><li>-D：解压前，不删除目录。</li><li>-T：禁止自动解压归档。</li></ul><p>%patch 命令 如果使用 %autosetup 命令，则不需要手动进行补丁管理。如果你的需求很复杂，或需要与 EPEL 兼容，需要用到此部分的内容。%patch0 命令用于应用 Patch0（%patch1 应用 Patch1，以此类推）。Patches 是修改源码的最佳方式。常用的 -pNUMBER 选项，向 patch 程序传递参数，表示跳过 NUM 个路径前缀。</p><p>补丁文件名通常像这样 telnet-0.17-env.patch，命名格式为 %{name} - %{version} - REASON.patch（有时省略 version 版本）。补丁文件通常是 diff -u 命令的输出；如果你在 ~/rpmbuild/BUILD 子目录执行此命令，则之后便不需要指定 -p 选项。</p><p>为一个文件制作补丁的步骤：</p><ol><li>cp foo/bar foo/bar.orig</li><li>vim foo/bar</li><li>diff -u foo/bar.orig foo/bar &gt; ~/rpmbuild/SOURCES/PKGNAME.REASON.patch</li></ol><p>如果需要修改多个文件，简单方法是复制 BUILD 下的整个子目录，然后在子目录执行 diff。切换至 ~rpmbuild/BUILD/NAME 目录后，执行以下命令：</p><ol><li>cp -pr ./ ../PACKAGENAME.orig/</li><li>… 执行修改 …</li><li>diff -ur ../PACKAGENAME.orig . &gt; ~/rpmbuild/SOURCES/NAME.REASON.patch</li></ol><p>如果你想在一个补丁中编辑多个文件，你可以在编辑之前，使用 .orig 扩展名复制原始文件。然后，使用 gendiff（在 rpm-build 包中）创建补丁文件。</p><h3 id="4-2-build阶段"><a href="#4-2-build阶段" class="headerlink" title="4.2 %build阶段"></a>4.2 %build阶段</h3><p>%build阶段顾名思义就是对解压到%_builddir下的源码进行编译的阶段，整个过程在该目录下完成。 许多程序使用 GNU configure 进行配置。默认情况下，文件会安装到前缀为 “/usr/local” 的路径下，对于手动安装很合理。然而，打包时需要修改前缀为 “/usr”。共享库路径视架构而定，安装至 /usr/lib 或 /usr/lib64 目录。 由于 GNU configure 很常见，可使用 %configure 宏来自动设置正确选项（例如，设置前缀为 /usr）。一般用法如下：</p><pre class="line-numbers language-none"><code class="language-none">%configuremake %&#123;?_smp_mflags&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>若需要覆盖 makefile 变量，请将变量作为参数传递给 make：</p><pre class="line-numbers language-none"><code class="language-none">make %&#123;?_smp_mflags&#125; CFLAGS&#x3D;&quot;%&#123;optflags&#125;&quot; BINDIR&#x3D;%&#123;_bindir&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>你会发现SPEC中会用到很多预定义好的宏，用来通过一个简单的宏来完成一个或一系列常见的操作，比如：<code>%prep</code>阶段用于解压的<code>%setup</code>和<code>%autosetup</code>，<code>%build</code>阶段的<code>%configure</code>等。</p></blockquote><h3 id="4-3-install阶段"><a href="#4-3-install阶段" class="headerlink" title="4.3 %install阶段"></a>4.3 %install阶段</h3><p>此阶段包含安装阶段需要执行的命令，即从 %{_builddir} 复制相关文件到 %{buildroot} 目录（通常表示从 ~/rpmbuild/BUILD 复制到 ~/rpmbuild/BUILDROOT/XXX) 目录，并根据需要在 %{buildroot} 中创建必要目录。</p><blockquote><p>容易混淆的术语：</p><ul><li>“build 目录”，也称为 %{_builddir}，实际上与 “build root”，又称为 %{buildroot}，是不同的目录。在前者中进行编译，并将需要打包的文件从前者复制到后者， %{buildroot}通常为 ~/rpmbuild/BUILD/%{name}-%{version}-%{release}.%{arch}。</li><li>在 %build 阶段，当前目录为 %{buildsubdir}，是 %prep 阶段中在 %{_builddir} 下创建的子目录。这些目录通常名为 ~/rpmbuild/BUILD/%{name}-%{version}。</li><li>%install 阶段的命令不会在用户安装 RPM 包时执行，此阶段仅在打包时执行。</li></ul></blockquote><p>一般，这里执行 “make install” 之类的命令：</p><pre class="line-numbers language-none"><code class="language-none">%installrm -rf %&#123;buildroot&#125; # 仅用于 RHEL 5%makeinstall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>理想情况下，对于支持的程序，你应该使用 %makeinstall（这又是一个宏），它等同于 DESTDIR=%{buildroot}，它会将文件安装到 %{buildroot} 目录中。</p><blockquote><p>使用 “%makeinstall” 宏。此方法可能有效，但也可能失败。该宏会展开为 make prefix=%{buildroot}%{*prefix} bindir=%{buildroot}%{*bindir} … install，可能导致某些程序无法正常工作。请在 %{buildroot} 根据需要创建必要目录。</p></blockquote><p>使用 auto-destdir 软件包的话，需要 BuildRequires: auto-destdir，并将 make install 修改为 make-redir DESTDIR=%{buildroot} install。这仅适用于使用常用命令安装文件的情况，例如 cp 和 install。 手动执行安装。这需要在 %{buildroot} 下创建必要目录，并从 %{_builddir} 复制文件至 %{buildroot} 目录。要特别注意更新，通常会包含新文件。示例如下：</p><pre class="line-numbers language-none"><code class="language-none">%installrm -rf %&#123;buildroot&#125;mkdir -p %&#123;buildroot&#125;%&#123;_bindir&#125;&#x2F;cp -p mycommand %&#123;buildroot&#125;%&#123;_bindir&#125;&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-4-check-阶段"><a href="#4-4-check-阶段" class="headerlink" title="4.4 %check 阶段"></a>4.4 %check 阶段</h3><p>如果需要执行测试，使用 %check 是个好主意。测试代码应写入 %check 部分（紧接在 %install 之后，因为需要测试 %{buildroot} 中的文件），而不是写入 %{build} 部分，这样才能在必要时忽略测试。通常，此部分包含：</p><pre class="line-numbers language-none"><code class="language-none">make test || make check<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-5-files-部分"><a href="#4-5-files-部分" class="headerlink" title="4.5 %files 部分"></a>4.5 %files 部分</h3><p>此部分列出了需要被打包的文件和目录。</p><p>%files 基础 %defattr 用于设置默认文件权限，通常可以在 %files 的开头看到它。注意，如果不需要修改权限，则不需要使用它。其格式为：</p><pre class="line-numbers language-none"><code class="language-none">%defattr(&lt;文件权限&gt;, &lt;用户&gt;, &lt;用户组&gt;, &lt;目录权限&gt;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第 4 个参数通常会省略。常规用法为 %defattr(-,root,root,-)，其中 “-” 表示默认权限。 您应该列出该软件包拥有的所有文件和目录。<strong>尽量使用宏代替目录名</strong>，具体的宏列表如下：</p><pre class="line-numbers language-none"><code class="language-none">%&#123;_sysconfdir&#125;        &#x2F;etc%&#123;_prefix&#125;            &#x2F;usr%&#123;_exec_prefix&#125;       %&#123;_prefix&#125;%&#123;_bindir&#125;            %&#123;_exec_prefix&#125;&#x2F;bin%&#123;_libdir&#125;            %&#123;_exec_prefix&#125;&#x2F;%&#123;_lib&#125;%&#123;_libexecdir&#125;        %&#123;_exec_prefix&#125;&#x2F;libexec%&#123;_sbindir&#125;           %&#123;_exec_prefix&#125;&#x2F;sbin%&#123;_sharedstatedir&#125;    &#x2F;var&#x2F;lib%&#123;_datarootdir&#125;       %&#123;_prefix&#125;&#x2F;share%&#123;_datadir&#125;           %&#123;_datarootdir&#125;%&#123;_includedir&#125;        %&#123;_prefix&#125;&#x2F;include%&#123;_infodir&#125;           &#x2F;usr&#x2F;share&#x2F;info%&#123;_mandir&#125;            &#x2F;usr&#x2F;share&#x2F;man%&#123;_localstatedir&#125;     &#x2F;var%&#123;_initddir&#125;          %&#123;_sysconfdir&#125;&#x2F;rc.d&#x2F;init.d%&#123;_var&#125;               &#x2F;var%&#123;_tmppath&#125;           %&#123;_var&#125;&#x2F;tmp%&#123;_usr&#125;               &#x2F;usr%&#123;_usrsrc&#125;            %&#123;_usr&#125;&#x2F;src%&#123;_lib&#125;               lib (lib64 on 64bit multilib systems)%&#123;_docdir&#125;            %&#123;_datadir&#125;&#x2F;doc%&#123;buildroot&#125;          %&#123;_buildrootdir&#125;&#x2F;%&#123;name&#125;-%&#123;version&#125;-%&#123;release&#125;.%&#123;_arch&#125;$RPM_BUILD_ROOT       %&#123;buildroot&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果路径以 “/” 开头（或从宏扩展），则从 %{buildroot} 目录取用。否则，假设文件在当前目录中（例如：在 %{_builddir} 中，包含需要的文档）。如果您的包仅安装一个文件，如 /usr/sbin/mycommand，则 %files 部分如下所示：</p><pre class="line-numbers language-none"><code class="language-none">%files%&#123;_sbindir&#125;&#x2F;mycommand<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>若要使软件包不受上游改动的影响，可使用通配符匹配所有文件：</p><pre class="line-numbers language-none"><code class="language-none">%&#123;_bindir&#125;&#x2F;*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>包含一个目录：</p><pre class="line-numbers language-none"><code class="language-none">%&#123;_datadir&#125;&#x2F;%&#123;name&#125;&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，<code>%&#123;_bindir&#125;/*</code> 不会声明此软件包拥有 /usr/bin 目录，而只包含其中的文件。如果您列出一个目录，则该软件包拥有这个目录，及该目录内的所有文件和子目录。因此，不要列出 %{_bindir}，并且要小心的处理那些可能和其他软件包共享的目录。</p><p>如果存在以下情况，可能引发错误：</p><ul><li>通配符未匹配到任何文件或目录</li><li>文件或目录被多次列出</li><li>未列出 %{buildroot} 下的某个文件或目录</li></ul><p>您也可以使用 %exclude 来排除文件。这对于使用通配符来列出全部文件时会很有用，注意如果未匹配到任何文件也会造成失败。</p><p><strong>%files 前缀</strong> 上边的“hello”的示例中，<code>%files</code>部分还有用到<code>%doc</code>等宏，可能您看得一知半解，这里详细介绍一下。 如果需要在 %files 部分添加一个或多个前缀，用空格分隔。</p><p><code>%doc</code> 用于列出 <code>%&#123;_builddir&#125;</code> 内，但不复制到 <code>%&#123;buildroot&#125;</code> 中的文档。通常包括 <code>README</code> 和 <code>INSTALL</code>等。它们会保存至 <code>/usr/share/doc</code> 下适当的目录中，不需要声明 <code>/usr/share/doc</code> 的所有权。</p><blockquote><p>注意： 如果指定 %doc 条目，rpmbuild &lt; 4.9.1 在安装前会将 %doc 目录删除。这表明已保存至其中的文档，例如，在 %install 中安装的文档会被删除，因此最终不会出现在软件包中。如果您想要在 %install 中安装一些文档，请将它们临时安装到 build 目录（不是 build root 目录）中，例如 _docs_staging，接着在 %files 中列出，如 %doc _docs_staging/* 这样。</p></blockquote><p>配置文件保存在 <code>/etc</code> 中，一般会这样指定（确保用户的修改不会在更新时被覆盖）：</p><pre class="line-numbers language-none"><code class="language-none">%config(noreplace) %&#123;_sysconfdir&#125;&#x2F;foo.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果更新的配置文件无法与之前的配置兼容，则应这样指定：</p><pre class="line-numbers language-none"><code class="language-none">%config %&#123;_sysconfdir&#125;&#x2F;foo.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>“%attr(mode, user, group)” 用于对文件进行更精细的权限控制，”-” 表示使用默认值：</p><pre class="line-numbers language-none"><code class="language-none">%attr(0644, root, root) FOO.BAR<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>“%caps(capabilities)” 用于为文件分配 POSIX capabilities。例如：</p><pre class="line-numbers language-none"><code class="language-none">%caps(cap_net_admin&#x3D;pe) FOO.BAR<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果包含特定语言编写的文件，请使用 %lang 来标注：</p><pre class="line-numbers language-none"><code class="language-none">%lang(de) %&#123;_datadir&#125;&#x2F;locale&#x2F;de&#x2F;LC_MESSAGES&#x2F;tcsh*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用区域语言（Locale）文件的程序应遵循 处理 i18n 文件的建议方法：</p><ul><li>在 %install 步骤中找出文件名： %find_lang ${name}</li><li>添加必要的编译依赖： BuildRequires: gettext</li><li>使用找到的文件名： %files -f ${name}.lang</li></ul><h3 id="4-6-Scriptlets"><a href="#4-6-Scriptlets" class="headerlink" title="4.6 Scriptlets"></a>4.6 Scriptlets</h3><p>当用户安装或卸载 RPM 时，您可能想要执行一些命令。这可以通过 scriptlets 完成。</p><p>脚本片段可以：</p><ul><li>在软体包安装之前 (<code>%pre</code>) 或之后 (<code>%post</code>) 执行</li><li>在软体包卸载之前 (<code>%preun</code>) 或之后 (<code>%postun</code>) 执行</li><li>在事务开始 (<code>%pretrans</code>) 或结束 (<code>%posttrans</code>) 时执行</li></ul><blockquote><p>例如，每个二进制 RPM 包都会在动态链接器的默认路径中存储共享库文件，并在 %post 和 %postun 中调用 ldconfig 来更新库缓存。如果软件包有多个包含共享库的子包，则每个软体包也需要执行相同动作。</p><p>%post -p /sbin/ldconfig %postun -p /sbin/ldconfig</p><p>如果仅执行一个命令，则 “-p” 选项会直接执行，而不启用 shell。然而，若有许多命令时，不要使用此选项，按正常编写 shell 脚本即可。</p></blockquote><p>如果你在脚本片段中执行任何程序，就必须以 <code>Requires(CONTEXT)</code>（例： <code>Requires(post)</code>）的形式列出所有依赖。</p><p><code>%pre</code>、<code>%post</code>、<code>%preun</code> 和 <code>%postun</code> 提供 <code>$1</code> 参数，表示动作完成后，系统中保留的此名称的软件包数量。因此可用于检查软件安装情况，不过不要比较此参数值是否等于 2，而是比较是否大于等于 2。对于<code>%pretrans</code> 和 <code>%posttrans</code>，$1 的值恒为 0。</p><p>例如，如果软件包安装了一份 info 手册，那么可以用 info 包提供的 install-info 来更新 info 手册索引。首先，我们不保证系统已安装 info 软件包，除非明确声明需要它；其次，我们不想在 install-info 执行失败时，使软件包安装失败：</p><pre class="line-numbers language-none"><code class="language-none">Requires(post): infoRequires(preun): info...%post&#x2F;sbin&#x2F;install-info %&#123;_infodir&#125;&#x2F;%&#123;name&#125;.info %&#123;_infodir&#125;&#x2F;dir || :%preunif [ $1 &#x3D; 0 ] ; then&#x2F;sbin&#x2F;install-info --delete %&#123;_infodir&#125;&#x2F;%&#123;name&#125;.info %&#123;_infodir&#125;&#x2F;dir || :fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上边的示例中还有一个安装 info 手册时的小问题需要解释一下。install-info 命令会更新 info 目录，所以我们应该在 <code>%install</code> 阶段删除 <code>%&#123;buildroot&#125;</code> 中无用的空目录：</p><pre class="line-numbers language-none"><code class="language-none">rm -f %&#123;buildroot&#125;%&#123;_infodir&#125;&#x2F;dir<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-命令及工具"><a href="#5-命令及工具" class="headerlink" title="5.命令及工具"></a>5.命令及工具</h2><h3 id="5-1-rpmbuild打包"><a href="#5-1-rpmbuild打包" class="headerlink" title="5.1 rpmbuild打包"></a>5.1 rpmbuild打包</h3><p>一旦 SPEC 编写完毕，请执行以下命令来构建 SRPM 和 RPM 包：</p><pre class="line-numbers language-none"><code class="language-none">rpmbuild -ba program.spec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果成功，RPM 会保存至 <code>~/rpmbuild/RPMS</code>，SRPM 会保存至 <code>~/rpmbuild/SRPMS</code>。</p><p>如果失败，请查看 BUILD 目录的相应编译日志。为了帮助调试，可以用 <code>--short-circuit</code> 选项来忽略成功的阶段。例如，若想要（略过更早的阶段）重新从 <code>%install</code> 阶段开始，请执行：</p><pre class="line-numbers language-none"><code class="language-none">rpmbuild -bi --short-circuit program.spec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果只想创建 RPM，请执行：</p><pre class="line-numbers language-none"><code class="language-none">rpmbuild -bb program.spec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果只想创建 SRPM（不需要执行 %prep 或 %build 或其他阶段），请执行：</p><pre class="line-numbers language-none"><code class="language-none">rpmbuild -bs program.spec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-2-rpmlint检查"><a href="#5-2-rpmlint检查" class="headerlink" title="5.2 rpmlint检查"></a>5.2 rpmlint检查</h3><p>为避免常见错误，请先使用 <code>rpmlint</code> 查找 SPEC 文件的错误：</p><pre class="line-numbers language-none"><code class="language-none">$ rpmlint program.spec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果返回错误/警告，使用 “-i” 选项查看更详细的信息。</p><p>也可以使用 <code>rpmlint</code> 测试已构建的 RPM 包，检查 SPEC/RPM/SRPM 是否存在错误。你需要在发布软件包之前，解决这些警告。此页面 提供一些常见问题的解释。如果你位于 SPEC 目录中，请执行：</p><pre class="line-numbers language-none"><code class="language-none">$ rpmlint NAME.spec ..&#x2F;RPMS&#x2F;*&#x2F;NAME*.rpm ..&#x2F;SRPMS&#x2F;NAME*.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入 <code>~/rpmbuild/RPMS</code> 下的特定架构目录中，您会发现有许多二进制 RPM 包。使用以下命令快速查看 RPM 包含的文件和权限：</p><pre class="line-numbers language-none"><code class="language-none">$ rpmls *.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-3-rpm安装"><a href="#5-3-rpm安装" class="headerlink" title="5.3 rpm安装"></a>5.3 rpm安装</h3><p>如果看上去正常，以 root 身份安装它们：</p><pre class="line-numbers language-none"><code class="language-none">$ rpm -ivp package1.rpm package2.rpm package3.rpm ...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以不同方式来测试程序，看看是否全部都正常工作。如果是 GUI 工具，请确认其是否出现在桌面菜单中，否则表示 .desktop 条目可能有错。 最后卸载软件包：</p><p>以不同方式来测试程序，看看是否全部都正常工作。如果是 GUI 工具，请确认其是否出现在桌面菜单中，否则表示 .desktop 条目可能有错。 最后卸载软件包：</p><pre class="line-numbers language-none"><code class="language-none">$ rpm -e package1 package2 package3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://linux.cn/article-10164-1.html">https://linux.cn/article-10164-1.html</a></p><p><a href="https://blog.csdn.net/get_set/article/details/53453320">https://blog.csdn.net/get_set/article/details/53453320</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> rpm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/01/27/hello-world/"/>
      <url>2021/01/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>quilt补丁制作</title>
      <link href="2021/01/27/quilt-bu-ding-zhi-zuo/"/>
      <url>2021/01/27/quilt-bu-ding-zhi-zuo/</url>
      
        <content type="html"><![CDATA[<h3 id="quilt"><a href="#quilt" class="headerlink" title="quilt"></a>quilt</h3><p>​        quilt是linux下一个制作和应用补丁的工具，debian包使用这个工具来管理源码包补丁。quilt用堆栈的概念管理补丁的应用。</p><h4 id="quilt补丁制作"><a href="#quilt补丁制作" class="headerlink" title="quilt补丁制作"></a>quilt补丁制作</h4><p>​        只要我们 在源代码树里使用了quilt命令，quilt就会在源代码树的根目录建立两个特殊目录：patches和.pc。patches下是它管理的补丁文件，.pc目录下保存着其内部工作状态。</p><h5 id="1-新建一个补丁文件"><a href="#1-新建一个补丁文件" class="headerlink" title="1.新建一个补丁文件"></a>1.新建一个补丁文件</h5><pre class="line-numbers language-none"><code class="language-none">quilt new xxx.patch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-将补丁和需要修改的文件关联"><a href="#2-将补丁和需要修改的文件关联" class="headerlink" title="2.将补丁和需要修改的文件关联"></a>2.将补丁和需要修改的文件关联</h5><pre class="line-numbers language-none"><code class="language-none">quilt add file<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关联后即可对文件进行修改，如要关联多个文件，重复添加然后修改即可。</p><h5 id="3-查看当前补丁是否正确"><a href="#3-查看当前补丁是否正确" class="headerlink" title="3.查看当前补丁是否正确"></a>3.查看当前补丁是否正确</h5><pre class="line-numbers language-none"><code class="language-none">quilt diff<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="4-保存补丁"><a href="#4-保存补丁" class="headerlink" title="4.保存补丁"></a>4.保存补丁</h5><pre class="line-numbers language-none"><code class="language-none">quilt refresh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>会保存在patches下。</p><h5 id="5-其它命令"><a href="#5-其它命令" class="headerlink" title="5.其它命令"></a>5.其它命令</h5><pre class="line-numbers language-none"><code class="language-none">quilt push -a应用所有补丁quilt pop -a撤消所有应用quilt push&#x2F;pop xxx应用&#x2F;撤消某个补丁quilt top查看栈顶补丁quilt import xxx导入一个补丁文件quilt files查看当前补丁中已修改的文件quilt series查看已管理的补丁quilt remove [patch] file 从补丁中移除文件quilt delete patch删除一个补丁<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="patch命令"><a href="#patch命令" class="headerlink" title="patch命令"></a>patch命令</h3><h4 id="使用diff制作补丁"><a href="#使用diff制作补丁" class="headerlink" title="使用diff制作补丁"></a>使用diff制作补丁</h4><pre class="line-numbers language-none"><code class="language-none">mkdir diffvi test1.txtvi test2.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>test1.txt文件内容如下</p><pre class="line-numbers language-none"><code class="language-none">aaaa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>test2.txt文件内容如下</p><pre class="line-numbers language-none"><code class="language-none">aaaabbbb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用diff命令制作patch文件</p><pre class="line-numbers language-none"><code class="language-none">diff -Naur test1.txt test2.txt &gt; test.patchdiff参数解释-N 在比较目录时如果某个文件只出现了一次，那么在比较不同时会默认和空文件比较-a 将所有的文件都作为普通text(之比较文本文件)-u 以合并的方式显示文件内容的不同-r 如果是文件夹则进行递归进行比较<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后在当前目录中会存在三个文件</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">test1<span class="token punctuation">.</span>txt test2<span class="token punctuation">.</span>txt test<span class="token punctuation">.</span>patch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>test.patch 文件的内容</p><pre class="line-numbers language-none"><code class="language-none">--- test1.txt   2018-08-01 13:17:33.530350672 +0800+++ test2.txt   2018-08-01 13:18:54.326350260 +0800@@ -1 +1,2 @@  aaaa+bbbb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用补丁更新文件</p><pre class="line-numbers language-none"><code class="language-none">patch -p0 &lt; testfile.patch <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>-pn为忽略目录，为1就忽略一级目录，为0不忽略。</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> quilt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my test</title>
      <link href="2021/01/20/my-test/"/>
      <url>2021/01/20/my-test/</url>
      
        <content type="html"><![CDATA[<h4 id="1-test"><a href="#1-test" class="headerlink" title="1.test"></a>1.test</h4><pre class="line-numbers language-none"><code class="language-none">echo hello world<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
